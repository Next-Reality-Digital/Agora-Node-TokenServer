name: Deploy Agora k8s

on:
  workflow_dispatch:
    inputs:
      key_vault_id:
        description: "Azure Key Vault ID"
        required: true
        type: string
      secret_name:
        description: "Secret Name"
        required: true
        type: string

jobs:
  deploy-app:
    runs-on: ubuntu-latest

    outputs:
      domain_name: ${{ steps.determine-domain.outputs.domain_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install Node.js 16.x
        uses: actions/setup-node@v2
        with:
          node-version: "16"

      - name: Install npm dependencies
        run: npm ci

      - name: Login to Azure Container Registry (ACR)
        uses: azure/docker-login@v1
        with:
          login-server: nextrealitydigital.azurecr.io
          username: ${{ secrets.AZURE_ACR_USERNAME }}
          password: ${{ secrets.AZURE_ACR_PASSWORD }}

      - name: Build Docker image
        run: |
          docker build -t agora-node-token-server:${{ github.sha }} .
      - name: Tag Docker image with latest and commit SHA
        run: |
          docker tag agora-node-token-server:${{ github.sha }} nextrealitydigital.azurecr.io/agora-node-token-server:latest
          docker tag agora-node-token-server:${{ github.sha }} nextrealitydigital.azurecr.io/agora-node-token-server:${{ github.sha }}
      - name: Push Docker image to ACR
        run: |
          docker push nextrealitydigital.azurecr.io/agora-node-token-server:latest
          docker push nextrealitydigital.azurecr.io/agora-node-token-server:${{ github.sha }}

      - name: Fetch Azure Function Secrets
        id: fetch-secrets
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status
      
          AZURE_FUNCTION_URL="${{ secrets.AZURE_FUNCTION_URL }}"
          AZURE_FUNCTION_CODE="${{ secrets.AZURE_FUNCTION_CODE }}"
          KEY_VAULT_ID="${{ github.event.inputs.key_vault_id }}"
          SECRET_NAME="${{ github.event.inputs.secret_name }}"
      
          # Function to fetch secrets from Azure Function
          fetch_secret() {
            local name=$1
            curl -s -H "Content-Type: application/json" -X GET "$AZURE_FUNCTION_URL?code=$AZURE_FUNCTION_CODE&key_vault_id=$KEY_VAULT_ID&name=$name" | sed 's/^Secret value: //; s/: /=/g'
          }
      
          # Fetch main secrets
          SECRETS=$(fetch_secret "$SECRET_NAME")
          if [ -z "$SECRETS" ]; then
              echo "Failed to retrieve secrets for $SECRET_NAME from Azure Function."
              exit 1
          fi
          echo "$SECRETS" > secrets.env
      
          # Fetch GitHub Actions secrets that include KUBECONFIG
          GH_ACTIONS_SECRETS=$(fetch_secret "github-actions")
          if [ -z "$GH_ACTIONS_SECRETS" ]; then
              echo "Failed to retrieve GitHub Actions secrets from Azure Function."
              exit 1
          fi
          echo "$GH_ACTIONS_SECRETS" > github_actions_secrets.env
      
          # Combine all secrets into a single .env file
          cat secrets.env github_actions_secrets.env > .env
      
          # Debug: Verify the format of .env (excluding sensitive data)
          echo "Combined .env file:"
          cat .env
      
          # Extract KUBECONFIG content using awk
          awk '
            /^KUBECONFIG=/ {
              # Remove "KUBECONFIG=" and start capturing
              sub(/^KUBECONFIG=/, "")
              print $0
              flag = 1
              next
            }
            /^[A-Z0-9_]+=/{ 
              # If another variable starts, stop capturing
              flag = 0 
            }
            flag {
              # Print each line as is
              print $0
            }
          ' .env > /tmp/kubeconfig

          # Verify that /tmp/kubeconfig is not empty
          if [ ! -s /tmp/kubeconfig ]; then
            echo "kubeconfig file is empty. Check the extraction process."
            exit 1
          fi

          # Set proper permissions
          chmod 600 /tmp/kubeconfig

          # Export KUBECONFIG environment variable for subsequent steps
          echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
      
          AGORA_DOMAIN_NAME=$(grep '^AGORA_DOMAIN_NAME=' .env | cut -d'=' -f2-)
          echo "DOMAIN_NAME=${AGORA_DOMAIN_NAME}" >> $GITHUB_ENV
      
      - name: Determine domain name
        id: determine-domain
        run: |
          DOMAIN_NAME=$(echo $DOMAIN_NAME | sed 's/^https:\/\///')
          echo "domain_name=$DOMAIN_NAME" >> $GITHUB_OUTPUT

      - name: Create or Update Kubernetes Secret Dynamically
        run: |
          # Set the KUBECONFIG environment variable
          export KUBECONFIG=/tmp/kubeconfig

          # Set the secret name from GitHub event inputs
          SECRET_NAME="${{ github.event.inputs.secret_name }}"

          # Parse variable names from .env.template
          VARIABLE_NAMES=($(grep -o '^[^=]*' .env.template))

          # Initialize a variable to hold --from-literal arguments
          LITERAL_ARGS=""

          # Loop over each variable name to construct --from-literal arguments
          for VAR_NAME in "${VARIABLE_NAMES[@]}"; do
            # Fetch the corresponding value from the .env file
            VAR_VALUE=$(grep "^$VAR_NAME=" .env | cut -d'=' -f2-)

            # Check if the value was found
            if [ -z "$VAR_VALUE" ]; then
              echo "Error: Value for $VAR_NAME not found in .env file."
              exit 1
            fi

            # Append the --from-literal argument
            LITERAL_ARGS="$LITERAL_ARGS --from-literal=$VAR_NAME=$VAR_VALUE"
          done

          # Create or update the Kubernetes secret
          kubectl create secret generic "$SECRET_NAME" $LITERAL_ARGS \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes with updated image
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          SECRET_NAME="${{ github.event.inputs.secret_name }}"

          kubectl set image deployment/agora-node-token-server app=nextrealitydigital.azurecr.io/agora-node-token-server:${{ github.sha }}

          kubectl set env --from=secret/$SECRET_NAME deployment/agora-node-token-server

  notify:
    name: Send notification
    runs-on: ubuntu-latest
    needs: [deploy-app]
    env:
      DOMAIN_NAME: ${{ needs.deploy-app.outputs.domain_name }}
    steps:
      - name: Notify slack channel
        id: slack-message
        uses: slackapi/slack-github-action@v1.24.0
        if: success()
        with:
          channel-id: ${{ secrets.SLACK_NOTIFICATIONS_CHANNEL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "✅ New service available! "
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Site Domain: `${{ env.DOMAIN_NAME }}`"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Check out the build log"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Visit the changes live"
                      },
                      "url": "https://${{ env.DOMAIN_NAME }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_NOTIFICATIONS_TOKEN }}

      - name: Notify slack channel on failure
        id: slack-failure-message
        uses: slackapi/slack-github-action@v1.24.0
        if: failure()
        with:
          channel-id: ${{ secrets.SLACK_NOTIFICATIONS_CHANNEL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "❌ Workflow failed!"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Site Domain: `${{ env.DOMAIN_NAME }}`"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Please check the workflow logs for more details."
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Logs"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_NOTIFICATIONS_TOKEN }}
