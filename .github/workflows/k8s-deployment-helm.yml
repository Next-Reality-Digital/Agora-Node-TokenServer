name: Docker Build and Deploy with Helm

on:
  workflow_dispatch:
    inputs:
      key_vault_id:
        description: "Azure Key Vault ID"
        required: true
        type: string
        default: "qa-metaverse"
      secret_name:
        description: "Secret Name"
        required: true
        type: string
        default: "api-agora-secrets"
      release_name:
        description: "Helm release name"
        required: true
        type: string
        default: "metaverse"
      metaverse_namespace:
        description: "Metaverse namespace"
        required: true
        type: string
        default: "metaverse"
      image_tag:
        type: choice
        options:
          - dev
          - latest
        description: "Image tag"
        required: false
        default: "dev"
      branch:
        type: string
        description: "Branch to deploy"
        required: true
        default: "main"
      image_name:
        type: string
        description: "Docker image name"
        required: true
        default: "agora-node-token-server"
  push:
    branches:
      - develop

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      registry_server: ${{ steps.set-outputs.outputs.registry_server }}
    steps:
      # checkout the repo
      - name: "Checkout GitHub Action"
        uses: actions/checkout@main
      
      - name: Fetch Secrets
        id: fetch-secrets
        run: |
          FUNCTION_URL="${{ secrets.AZURE_FUNCTION_URL }}"
          FUNCTION_CODE="${{ secrets.AZURE_FUNCTION_CODE }}"
          KEY_VAULT_ID="${{ github.event.inputs.key_vault_id }}"

          # Fetch GitHub actions secrets that include KUBECONFIG
          GH_ACTIONS_URL="$FUNCTION_URL?code=$FUNCTION_CODE&key_vault_id=$KEY_VAULT_ID&name=github-actions"
          GH_ACTIONS_RESPONSE=$(curl -s -H "Content-Type: application/json" -X GET "$GH_ACTIONS_URL")
          
          if [ -z "$GH_ACTIONS_RESPONSE" ]; then
              echo "Failed to retrieve GitHub Actions secrets from Azure Function."
              exit 1
          fi
          
          echo "Raw response from Azure Function:"
          echo "$GH_ACTIONS_RESPONSE"
          
          # Try to extract JSON from response (handles both raw JSON and "Secret value: {...}" format)
          if echo "$GH_ACTIONS_RESPONSE" | jq empty 2>/dev/null; then
              # Response is already valid JSON
              GH_ACTIONS_SECRETS="$GH_ACTIONS_RESPONSE"
          elif echo "$GH_ACTIONS_RESPONSE" | grep -q "^Secret value: "; then
              # Response has "Secret value: " prefix, remove it
              GH_ACTIONS_SECRETS=$(echo "$GH_ACTIONS_RESPONSE" | sed 's/^Secret value: //')
          else
              echo "Unexpected response format from Azure Function:"
              echo "$GH_ACTIONS_RESPONSE"
              exit 1
          fi
          
          # Validate that we now have valid JSON
          if ! echo "$GH_ACTIONS_SECRETS" | jq empty 2>/dev/null; then
              echo "Invalid JSON after processing:"
              echo "$GH_ACTIONS_SECRETS"
              exit 1
          fi

          # Extract the REGISTRY_SERVER, REGISTRY_USERNAME, REGISTRY_PASSWORD from the GH_ACTIONS_SECRETS
          REGISTRY_SERVER=$(echo "$GH_ACTIONS_SECRETS" | jq -r '.REGISTRY_SERVER')
          REGISTRY_USERNAME=$(echo "$GH_ACTIONS_SECRETS" | jq -r '.REGISTRY_USERNAME')
          REGISTRY_PASSWORD=$(echo "$GH_ACTIONS_SECRETS" | jq -r '.REGISTRY_PASSWORD')
          
          # Validate that required values were extracted
          if [ "$REGISTRY_SERVER" = "null" ] || [ "$REGISTRY_USERNAME" = "null" ] || [ "$REGISTRY_PASSWORD" = "null" ]; then
              echo "Failed to extract required registry credentials from secrets:"
              echo "REGISTRY_SERVER: $REGISTRY_SERVER"
              echo "REGISTRY_USERNAME: $REGISTRY_USERNAME"
              echo "REGISTRY_PASSWORD: [hidden]"
              exit 1
          fi

          # Put the REGISTRY_SERVER, REGISTRY_USERNAME, REGISTRY_PASSWORD in the $GITHUB_ENV
          echo "REGISTRY_SERVER=$REGISTRY_SERVER" >> $GITHUB_ENV
          echo "REGISTRY_USERNAME=$REGISTRY_USERNAME" >> $GITHUB_ENV
          echo "REGISTRY_PASSWORD=$REGISTRY_PASSWORD" >> $GITHUB_ENV
          
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_SERVER }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Build and push Docker image
        run: |
          REGISTRY="${{ env.REGISTRY_SERVER }}"
          IMAGE_NAME="${{ github.event.inputs.image_name || 'agora-node-token-server' }}"
          docker build -t $REGISTRY/$IMAGE_NAME:${{ github.sha }} .
          docker push $REGISTRY/$IMAGE_NAME:${{ github.sha }}
          
      - name: Update tag
        run: |
          REGISTRY="${{ env.REGISTRY_SERVER }}"
          IMAGE_NAME="${{ github.event.inputs.image_name || 'agora-node-token-server' }}"
          if [ "${{ github.event.inputs.image_tag }}" == "latest" ]; then
            docker tag $REGISTRY/$IMAGE_NAME:${{ github.sha }} $REGISTRY/$IMAGE_NAME:latest
            docker push $REGISTRY/$IMAGE_NAME:latest
          else
            docker tag $REGISTRY/$IMAGE_NAME:${{ github.sha }} $REGISTRY/$IMAGE_NAME:dev  
            docker push $REGISTRY/$IMAGE_NAME:dev
          fi

      - name: Set outputs
        id: set-outputs
        run: |
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "registry_server=${{ env.REGISTRY_SERVER }}" >> $GITHUB_OUTPUT

  trigger_workflow:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.branch
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Trigger Helm Chart deployment
        uses: convictional/trigger-workflow-and-wait@v1.6.1
        with:
          owner: ${{ github.repository_owner }}
          repo: metaverse-helm-charts
          github_token: ${{ secrets.ORG_TOKEN }}
          workflow_file_name: deploy.yaml
          ref: ${{ github.event.inputs.branch }}
          wait_interval: 20
          propagate_failure: true
          trigger_workflow: true
          wait_workflow: true
          client_payload: |
            {
              "image_tag": "${{ github.sha }}",
              "image_name": "${{ github.event.inputs.image_name || 'agora-node-token-server' }}",
              "image_registry": "${{ needs.build.outputs.registry_server }}",
              "key_vault_id": "${{ github.event.inputs.key_vault_id }}",
              "secret_name": "${{ github.event.inputs.secret_name }}",
              "app_to_deploy": "agora-token-server",
              "release_name": "${{ github.event.inputs.release_name }}",
              "metaverse_namespace": "${{ github.event.inputs.metaverse_namespace }}"
            }

  tigger_dev_workflow:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Trigger Helm Chart deployment
        uses: convictional/trigger-workflow-and-wait@v1.6.1
        with:
          owner: ${{ github.repository_owner }}
          repo: metaverse-helm-charts
          github_token: ${{ secrets.ORG_TOKEN }}
          workflow_file_name: deploy.yaml
          ref: main
          wait_interval: 20
          propagate_failure: true
          trigger_workflow: true
          wait_workflow: true
          client_payload: |
            {
              "image_tag": "${{ github.sha }}",
              "image_name": "agora-node-token-server",
              "image_registry": "${{ needs.build.outputs.registry_server }}",
              "key_vault_id": "qa-metaverse",
              "secret_name": "api-agora-secrets",
              "app_to_deploy": "agora-token-server",
              "release_name": "metaverse",
              "metaverse_namespace": "metaverse"
            }